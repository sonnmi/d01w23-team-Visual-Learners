# **Matplotlib Architecture Analysis**

## **Architecture Style and Structure**
Matplotlib has a *Layered Architecture* style; modules with similar functionalities and responsibilities are organized into horizontal layers, which allows each layer performs a specific role within the application. Matplotlib encapsulates the drawing interfaces to enable rendering to multiple devices as well as basic event handling and windowing; this design allows users to create rich interactive graphics involving mouse and keyboard input. In other words, it abstracts the view of the system as a whole while providing enough information to understand the responsibilities of each layer and their relationships.

To accomplish the design, the Matplotlib architecture consists of three layers, which can be viewed as a stack. The lower layers are not aware of the layers above them, while each layer that sits above another layer can communicate with the layer below it. The three layers in Matplotlib architecture from bottom to top are: backend, artist, and scripting.

<br>

## **UML Diagrams**
The UML diagrams generated by reverse engineering tools are in the folder diagrams.reverse_engineering_tools.

<br>

Our team has created diagrams for each layer defined in Matplotlib.
The following are diagrams our team has genereated:

### 1. Backend Layer
![screensh](./diagrams/Backend%20Layer.svg)
<!-- <p align="center">
    <img src="./diagrams/Backend%20Layer.png" width="100%" height="100%" style="display:flex; justify-content: center;" />
<p/> -->
Matplotlib.backends is responsible for providing the support of outputting on various use cases and formats. There are two types of backends. One is called user interface backend by Matplotlib, which contains PyQt, PyGObject, etc., And the other one is hardcopy backend, which includes different formats of image files like PNG, SVG, etc., For each of the GUIs and formats supported, there exists a corresponding backend. The backend layer works behind the artist layer. After the artist layer finishes creating diagrams, the backend layer provides the capacity of generating the diagrams to adapt to all these UI toolkits and file formats included in the backends.

<br>

Backend classes are all different but extend certain common base classes: `RendererBase`, `FigureCanvasBase`, and `GraphicsContextBase`.  `RendererBase` is the abstract class that provides a low-level drawing interface and methods for rendering operations. It does the drawing like a paint brush. `FigureCanvasBase` is the abstraction of the figure being rendered. FigureCanvas encapsulates the ides of a surface to draw onto such as the paper. `GraphicsContextBase` is the abstract class for providing lines, colors, etc. The abstractions involve most methods a backend in Matplotlib requires and provide the capability for the Artist layer to treat each backend uniformly independent from GUI or format to render. `Event` class handles user interactions such as mouse events and keyboard inputs. It maps underlying UI events such as `key_press_event` or `mouse_motion_event` to the classes `KeyEvent` or `MouseEvent`, which extend `LoacationEvent` that inherits from `Event`. Users can interact with figures and data by connecting to these events to callback functions; for example, users can pick a group of data points and manipulate the data.


<br>

### 2. Artist Layer
![screensh](./diagrams/Artist%20Layer.svg)
The artist layer in Matplotlib provides an object-oriented interface for creating and manipulating the visual elements of a plot. At its core, Matplotlib represents a plot as a hierarchy of objects, where each object represents a visual element such as a line, marker, or text label. The main objects in the artist layer are the Figure, Axes, and Artist classes. The Artist class is the base class for all visual elements in Matplotlib, and it provides a common interface for setting properties such as the color, linestyle, and linewidth of an element. There are many subclasses of the Artist class, including Line2D, Patch, and Text, which represent different types of visual elements.

<br>

The `Artist` module presents a general outline for all visible elements that will be rendered onto a `FigureCanvas`. `Artist` is the abstract base class that contains methods and properties that every visible element will need. `Artist` has functions that `draw` and `update` and properties like `zorder` to understand which element appears at the front. Subclasses of `Artist` include lines (`Line2D`), shapes (`Patch`), text (`Text`), etc.

The `Line2D` module contains the class `Line2D` which is a subclass of `Artist` responsible for how a particular line is styled from the marker at each vertex to the pattern of the whole line. Along with methods and properties that `Line2D` inherited from the `Artist` class, it also has methods to set and get the line style or width among other things.

The `Text` module is responsible for storing and drawing the specifics of text. The base class `Text` stores the x and y coordinates, the text string, and color. `Annotation` is a subclass that extends `Text`. In the context of figures, annotations are comments that help explain or clarify the plots. An `Annotation` can have arrows or other elements of `Patches` along with the text to assist with the explanation.

`FigureBase` is the top level container for all the plot elements. It inherits `Artist` class. `Figure` class, which inherits `FigureBase`, is the top-level Matplotlib object that contains and manages every element in a graphic. A `Figure` object is the outermost container for a matplotlib graphic, which contains multiple Axes objects. Note that Axes in Matplotlib is an individual plot or graph rather than the plural of “axis”.

`Axes` class represents one sub-plot in a figure. `Axes` object encapsulates every element of an individual plot in a figure; it contains the plotted data, axis ticks, labels, title, legend, etc. Its methods are used to create and manipulate the plot. It allows placement of plots at any location in a figure. Note that a `Figure` can contain multiple axes, but a given `Axes` object can only be in one figure. The `Axes` object can contain two axis objects or three axis objects in the case of 3D. Each `Axes` has a `XAxis` and `YAxis`, each of which contains a collection of major ticks.

`XAxis` and `YAxis` both extend the base class `Axis`. `Axis` and `Tick` have a composition relationship. To configure the location and format of the ticks, `Axis` also has an aggregation relationship with `Locator` and `Formatter`.

`Locator` and `Formatter` are major classes in matplotlib.ticker and are responsible for the location and format of ticks respectively. They both extend `TickHelper`, which has an aggregation with `Axis`.

Matplotlib’s image module includes many classes that support basic image loading, rescaling and display operations. A few examples of the classes, which all inherit the `_ImageBase` class, are: `AxesImage`, `BboxImage`, and `FigureImage`. `AxesImage` represents an image attached to an `Axes`, and FigureImage represents an image attached to a `Figure`.

The `Collection` module represents a sequence of patches that could be drawn together more effectively. The base class `Collection` extends `Artist` and `ScalarMappable`. Subclasses of `Collection` are about grouping particular shapes, from lines (`LineCollection`), ellipses (`EllipseCollection`), polygons (`PolyCollection`), etc.

The `Colors` module is responsible for converting numbers or color arguments to `RGB` or `ARGB` formats, sequences of 3 or 4 floats in the range of 0 to 1.  The module includes functions for color specification conversions.  The classes in the module are `Normalize` and its subclasses, `Colormap` and its subclasses, `ColorConverter`, `ColorSequenceRegistry`, `LightSource` and `Norm`.  `Normalize` and its nine subclasses are classes that linearly normalize data into the [0.0, 1.0] interval.  This data is then used to map to a color with `ColorMap` and its two subclasses.  The class `ColorSequenceRegistry` is a container for sequences of colors that are known to Matplotlib by name.  Class `LightSource` is used to create light sourcing from specified `azimuth` and `elevation`.  Class `Norm` handles unexpected cases and redirects to the default processing method.  Class `ColorConverter` is used for backward compatibility. This class’ functionality is entirely provided by module-level functions.

The `cm` module contains built-in colormaps, colormap handling utilities and the `ScalarMappable` mixin.  Subclasses in this module are `ColormapRegistry` and `ScalarMappable`, with no subclasses for these classes.   `ColormapRegistry` is a container for colormaps that are known to Matplotlib by name. `ScalarMappable` is a mixin class to map scalar data to `RGBA`.  This class applies data normalization before returning `RGBA` colors from the given colormap.

<br>

### 3. Scripting Layer
![screensh](./diagrams/Scripting%20Layer.png)
The scripting layer in Matplotlib provides a user-friendly interface for creating and customizing plots. The scripting layer uses the other layers (Artist and Backend) to provide a set of high-level functions and classes that simplify the process of creating plots. The pyplot module is the main module for the scripting layer, which provides a stateful interface for creating and modifying figures and axes. This means that you can create a new figure, add one or more subplots to it, and then add lines, markers, and other visual elements to the subplots, all with a few lines of code.

This is accomplished by importing the different packages from the other layers as shown in the UML diagram. For example, Artist, Figure and Axes are necessary for pyplot to create a new figure and add subplots. It also utilizes other external packages and libraries like threading for performance.



<br>
<br>

## **Degree of Coupling**
As discussed earlier, Matplotlib has Layered architecture; each layer is a grouping of modules that provides a cohesive set of services. With the properties of layered architecture, if it has not been designed and managed properly, communication between layers can become complicated. However, since every module is allocated to one layer and grouped by similar responsibilities, it obeys Single-responsibility Principle (SRP), which ensures high cohesion.

Recall that part of the responsibility for the backend layer is to export the figure in many different formats like pdf, svg, etc. This is done by inheriting the interfaces defined in backend_bases.py. With a backend implemented, it can be registered and used by the other layers by the user. By separating both the rendering and the export method from the core plotting functionality, it has a low degree of coupling.

The Artist Layer especially follows the Interface Segregation Principle. Every visual element inherits from the Artist class or another class that eventually inherits the Artist class. Each subclass has a specific set of attributes and methods that are related to the creation and manipulation of a particular visual element. For example, the Line2D and the Rectangle class are both subclasses of the Patches class (which is a subclass of Artist) and they only contain functions and properties that are specific to the appearance of the line or the rectangle itself. Any common behavior between the two classes are covered by the parent class they are both inheriting from. Therefore, each subclass is closely related to its purpose meaning it has high cohesion. Moreover, these subclasses are designed to work independently of each other and do not depend on each other to function properly. This means that the subclasses have low coupling since they do not depend on each other.


<br>
<br>

## **Improvements**

The current implementation of a class `Circle` has a so-called *Circle-Ellipse problem*, which is a violation of *the Liskov Substitution Principle*. The problem concerns the difficulties that occur when a base class contains methods that mutate an object and invalidate an invariant in a derived class.


A circle can be defined as an ellipse with the same width and length. Thus, the code implements a class `Circle` a subclass of a class `Ellipse`. A subclass must implement any mutator methods defined in a base class to provide a super class's behaviour. The method Ellipse.set_width alters the width and Ellipse.set_height changes the height of an ellipse. Since `Circle` inherits from `Ellipse`, it also has methods set_width and set_height. The methods would alter the length of one of its axes, which makes the circle with a different width or height no longer a circle. The `Circle` class cannot satisfy its own invariant and the requirements of the `Ellipse`. Moreover, since an ellipse has different conditions from a circle, if `Circle` inherits from `Ellipse`, it gets unnecessary attributes. For example, `Ellipse` needs attributes to specify the length and rotation of the axes as shown in the code, but a `Circle` only requires a radius.

<br>

The following are the corresponding codes:

[Code Snippet: Class Ellipse in patches.py](
https://github.com/matplotlib/matplotlib/blob/d6dd1b79142e4e2483244c25ff1e3ddb664722d3/lib/matplotlib/patches.py#L1512-L1662)
```python
class Ellipse(Patch):
    """A scale-free ellipse."""

    def __init__(self, xy, width, height, angle=0, **kwargs):
        super().__init__(**kwargs)
        self._center = xy
        self._width, self._height = width, height
        self._angle = angle
        self._path = Path.unit_circle()
        self._aspect_ratio_correction = 1.0
        self._patch_transform = transforms.IdentityTransform()

    def _recompute_transform(self):
        center = (self.convert_xunits(self._center[0]),
                  self.convert_yunits(self._center[1]))
        width = self.convert_xunits(self._width)
        height = self.convert_yunits(self._height)
        self._patch_transform = transforms.Affine2D() \
            .scale(width * 0.5, height * 0.5 * self._aspect_ratio_correction) \
            .rotate_deg(self.angle) \
            .scale(1, 1 / self._aspect_ratio_correction) \
            .translate(*center)

    def get_patch_transform(self):
        self._recompute_transform()
        return self._patch_transform

    def set_width(self, width):
        """Set the width of the ellipse."""
        self._width = width
        self.stale = True

    def get_width(self):
        return self._width

    width = property(get_width, set_width)

    def set_height(self, height):
        """Set the height of the ellipse."""
        self._height = height
        self.stale = True

    def get_height(self):
        return self._height

    height = property(get_height, set_height)

    def set_angle(self, angle):
        """Set the angle of the ellipse."""
        self._angle = angle
        self.stale = True

    def get_angle(self):
        return self._angle

    angle = property(get_angle, set_angle)

...

```

<br>

[Code Snippet: Class Circle in patches.py](
https://github.com/matplotlib/matplotlib/blob/d6dd1b79142e4e2483244c25ff1e3ddb664722d3/lib/matplotlib/patches.py#L1852-L1891)
```python
class Circle(Ellipse):
    def __init__(self, xy, radius=5, **kwargs):
        super().__init__(xy, radius * 2, radius * 2, **kwargs)
        self.radius = radius

    def set_radius(self, radius):
        """
        Set the radius of the circle.
        """
        self.width = self.height = 2 * radius
        self.stale = True

    def get_radius(self):
        """Return the radius of the circle."""
        return self.width / 2.

    radius = property(get_radius, set_radius)
```

<br>

We can use "Composition over inheritance" for the *Circle-Ellipse problem*. We can implement a class `Circle` by dropping inheritance relationships and making internal use of an Ellipse object. By this approach, `Circle` can have its own interface and invariants, which decouples from the invariants of `Ellipse`. This design ensures less coupling even when both are mutable classes. Because we remove inheritance, there would be no *LSP (Liskov Substitution Principle)* violation, thus solving the *Circle-Ellipse problem*.

<br>

## **References**
1. ["Is a Circle a kind-of an Ellipse?" by Marshall Cline at C++ FAQ](
https://web.archive.org/web/20130914063508/http://www.parashift.com/c++-faq-lite/circle-ellipse.html)
2. ["Layered Architecture" by University of Waterloo](https://cs.uwaterloo.ca/~m2nagapp/courses/CS446/1195/Arch_Design_Activity/Layered.pdf)
